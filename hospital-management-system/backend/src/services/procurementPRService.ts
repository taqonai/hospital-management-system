import prisma from '../config/database';
import { NotFoundError, AppError } from '../middleware/errorHandler';
import { PRUrgency, PRStatus, ProcurementItemType, ApprovalStatus } from '@prisma/client';

// Helper function to create notification
async function createNotification(userId: string, title: string, message: string, data?: any) {
  try {
    await prisma.notification.create({
      data: {
        userId,
        title,
        message,
        type: 'SYSTEM',
        data,
        isRead: false,
      },
    });
  } catch (error) {
    console.error('[NOTIFICATION] Failed to create notification:', error);
    // Don't throw - notification failure shouldn't block main operation
  }
}

// ==================== Purchase Requisition CRUD ====================

export async function createPR(hospitalId: string, userId: string, data: {
  departmentId: string;
  urgency?: PRUrgency;
  justification?: string;
  requiredDate?: Date;
  notes?: string;
  isAutoGenerated?: boolean;
  items: Array<{
    itemType: ProcurementItemType;
    itemReferenceId?: string;
    itemName: string;
    itemCode?: string;
    specification?: string;
    unit: string;
    quantity: number;
    estimatedUnitCost: number;
    preferredSupplier?: string;
    notes?: string;
  }>;
}) {
  // Generate PR number
  const year = new Date().getFullYear();
  const hospital = await prisma.hospital.findUnique({
    where: { id: hospitalId },
    select: { code: true },
  });

  const count = await prisma.purchaseRequisition.count({
    where: { hospitalId, createdAt: { gte: new Date(`${year}-01-01`) } },
  });
  const seq = String(count + 1).padStart(5, '0');
  const prNumber = `PR-${hospital?.code || 'HOS'}-${year}-${seq}`;

  // Calculate items totals
  const items = data.items.map(item => ({
    ...item,
    estimatedTotal: item.quantity * item.estimatedUnitCost,
  }));
  const totalEstimated = items.reduce((sum, i) => sum + i.estimatedTotal, 0);

  return prisma.purchaseRequisition.create({
    data: {
      hospitalId,
      prNumber,
      requestedById: userId,
      departmentId: data.departmentId,
      urgency: data.urgency || 'ROUTINE',
      status: 'DRAFT_PR',
      justification: data.justification,
      requiredDate: data.requiredDate,
      notes: data.notes,
      isAutoGenerated: data.isAutoGenerated || false,
      totalEstimated,
      items: {
        create: items,
      },
    },
    include: {
      items: true,
      requestedBy: { select: { id: true, firstName: true, lastName: true } },
      department: { select: { id: true, name: true, code: true } },
    },
  });
}

export async function listPRs(hospitalId: string, params: {
  status?: PRStatus;
  departmentId?: string;
  urgency?: PRUrgency;
  requestedById?: string;
  search?: string;
  page?: number;
  limit?: number;
}) {
  const where: any = { hospitalId };

  if (params.status) where.status = params.status;
  if (params.departmentId) where.departmentId = params.departmentId;
  if (params.urgency) where.urgency = params.urgency;
  if (params.requestedById) where.requestedById = params.requestedById;
  if (params.search) {
    where.OR = [
      { prNumber: { contains: params.search, mode: 'insensitive' } },
      { justification: { contains: params.search, mode: 'insensitive' } },
    ];
  }

  const page = params.page || 1;
  const limit = params.limit || 20;
  const skip = (page - 1) * limit;

  const [requisitions, total] = await Promise.all([
    prisma.purchaseRequisition.findMany({
      where,
      skip,
      take: limit,
      orderBy: { createdAt: 'desc' },
      include: {
        requestedBy: { select: { id: true, firstName: true, lastName: true } },
        department: { select: { id: true, name: true, code: true } },
        _count: { select: { items: true } },
      },
    }),
    prisma.purchaseRequisition.count({ where }),
  ]);

  return { requisitions, total, page, limit, totalPages: Math.ceil(total / limit) };
}

export async function getPRById(hospitalId: string, prId: string) {
  const pr = await prisma.purchaseRequisition.findFirst({
    where: { id: prId, hospitalId },
    include: {
      items: true,
      requestedBy: { select: { id: true, firstName: true, lastName: true, email: true } },
      department: { select: { id: true, name: true, code: true } },
      approvals: {
        include: {
          approver: { select: { id: true, firstName: true, lastName: true } },
        },
        orderBy: { level: 'asc' },
      },
      purchaseOrders: {
        select: { id: true, poNumber: true, status: true },
      },
    },
  });

  if (!pr) throw new NotFoundError('Purchase requisition not found');
  return pr;
}

export async function updatePR(hospitalId: string, prId: string, data: {
  urgency?: PRUrgency;
  justification?: string;
  requiredDate?: Date;
  notes?: string;
  items?: Array<{
    id?: string;
    itemType: ProcurementItemType;
    itemReferenceId?: string;
    itemName: string;
    itemCode?: string;
    specification?: string;
    unit: string;
    quantity: number;
    estimatedUnitCost: number;
    preferredSupplier?: string;
    notes?: string;
  }>;
}) {
  const pr = await prisma.purchaseRequisition.findFirst({
    where: { id: prId, hospitalId },
  });
  if (!pr) throw new NotFoundError('Purchase requisition not found');
  if (pr.status !== 'DRAFT_PR') {
    throw new AppError('Can only edit draft requisitions', 400);
  }

  const updateData: any = {};
  if (data.urgency) updateData.urgency = data.urgency;
  if (data.justification !== undefined) updateData.justification = data.justification;
  if (data.requiredDate !== undefined) updateData.requiredDate = data.requiredDate;
  if (data.notes !== undefined) updateData.notes = data.notes;

  // Replace items if provided
  if (data.items) {
    await prisma.pRItem.deleteMany({ where: { prId } });
    const items = data.items.map(item => ({
      ...item,
      prId,
      estimatedTotal: item.quantity * item.estimatedUnitCost,
    }));
    await prisma.pRItem.createMany({ data: items });
    updateData.totalEstimated = items.reduce((sum, i) => sum + i.estimatedTotal, 0);
  }

  return prisma.purchaseRequisition.update({
    where: { id: prId },
    data: updateData,
    include: {
      items: true,
      requestedBy: { select: { id: true, firstName: true, lastName: true } },
      department: { select: { id: true, name: true, code: true } },
    },
  });
}

// ==================== PR Workflow ====================

export async function submitPR(hospitalId: string, prId: string, userId: string) {
  const pr = await prisma.purchaseRequisition.findFirst({
    where: { id: prId, hospitalId },
    include: { items: true },
  });
  if (!pr) throw new NotFoundError('Purchase requisition not found');
  if (pr.status !== 'DRAFT_PR') {
    throw new AppError('Can only submit draft requisitions', 400);
  }
  if (!pr.items.length) {
    throw new AppError('Cannot submit requisition with no items', 400);
  }

  // Create a simple single-level approval (can be extended with workflow engine)
  return prisma.$transaction(async (tx) => {
    // Find approval workflows for this hospital
    const workflow = await tx.approvalWorkflow.findFirst({
      where: { hospitalId, type: 'PR_WORKFLOW', isActive: true },
      include: { levels: { orderBy: { level: 'asc' } } },
    });

    const updated = await tx.purchaseRequisition.update({
      where: { id: prId },
      data: { status: 'SUBMITTED' },
      include: {
        items: true,
        requestedBy: { select: { id: true, firstName: true, lastName: true } },
        department: { select: { id: true, name: true, code: true } },
      },
    });

    // If no workflow, auto-move to pending approval
    if (!workflow || !workflow.levels.length) {
      await tx.purchaseRequisition.update({
        where: { id: prId },
        data: { status: 'PENDING_APPROVAL' },
      });
    } else {
      // Create approval records for each level
      const approverIds: string[] = [];
      for (const level of workflow.levels) {
        if (level.approverId) {
          await tx.pRApproval.create({
            data: {
              prId,
              approverId: level.approverId,
              level: level.level,
              status: 'PENDING_APPROVAL_STATUS',
            },
          });
          approverIds.push(level.approverId);
        }
      }
      await tx.purchaseRequisition.update({
        where: { id: prId },
        data: { status: 'PENDING_APPROVAL' },
      });

      // Send notifications to approvers
      for (const approverId of approverIds) {
        await createNotification(
          approverId,
          'New Purchase Requisition for Approval',
          `Purchase Requisition ${pr.prNumber} has been submitted and requires your approval.`,
          { prId, prNumber: pr.prNumber, action: 'PR_SUBMITTED' }
        );
      }
    }

    return updated;
  });
}

export async function approvePR(hospitalId: string, prId: string, approverId: string, comments?: string) {
  const pr = await prisma.purchaseRequisition.findFirst({
    where: { id: prId, hospitalId },
    include: { approvals: true },
  });
  if (!pr) throw new NotFoundError('Purchase requisition not found');
  if (pr.status !== 'PENDING_APPROVAL' && pr.status !== 'SUBMITTED') {
    throw new AppError('Requisition is not pending approval', 400);
  }

  return prisma.$transaction(async (tx) => {
    // Update or create approval record
    const existingApproval = pr.approvals.find(a => a.approverId === approverId);
    if (existingApproval) {
      await tx.pRApproval.update({
        where: { id: existingApproval.id },
        data: {
          status: 'APPROVED_STATUS',
          comments,
          actedAt: new Date(),
        },
      });
    } else {
      await tx.pRApproval.create({
        data: {
          prId,
          approverId,
          level: 1,
          status: 'APPROVED_STATUS',
          comments,
          actedAt: new Date(),
        },
      });
    }

    // Check if all approvals are done
    const pendingApprovals = await tx.pRApproval.count({
      where: { prId, status: 'PENDING_APPROVAL_STATUS' },
    });

    const newStatus = pendingApprovals === 0 ? 'APPROVED_PR' : 'PENDING_APPROVAL';

    const updated = await tx.purchaseRequisition.update({
      where: { id: prId },
      data: {
        status: newStatus as PRStatus,
        ...(newStatus === 'APPROVED_PR' ? {
          approvedAt: new Date(),
          approvedById: approverId,
        } : {}),
      },
      include: {
        items: true,
        requestedBy: { select: { id: true, firstName: true, lastName: true } },
        department: { select: { id: true, name: true, code: true } },
        approvals: {
          include: { approver: { select: { id: true, firstName: true, lastName: true } } },
        },
      },
    });

    // Send notification to requester when fully approved
    if (newStatus === 'APPROVED_PR') {
      const approver = await tx.user.findUnique({
        where: { id: approverId },
        select: { firstName: true, lastName: true },
      });
      const approverName = approver ? `${approver.firstName} ${approver.lastName}` : 'Admin';

      await createNotification(
        pr.requestedById,
        'Purchase Requisition Approved',
        `Your Purchase Requisition ${pr.prNumber} has been approved by ${approverName}.`,
        { prId, prNumber: pr.prNumber, action: 'PR_APPROVED' }
      );
    }

    return updated;
  });
}

export async function rejectPR(hospitalId: string, prId: string, rejectedById: string, reason: string) {
  const pr = await prisma.purchaseRequisition.findFirst({
    where: { id: prId, hospitalId },
  });
  if (!pr) throw new NotFoundError('Purchase requisition not found');
  if (pr.status !== 'PENDING_APPROVAL' && pr.status !== 'SUBMITTED') {
    throw new AppError('Requisition is not pending approval', 400);
  }

  return prisma.$transaction(async (tx) => {
    // Update the approval record if exists
    const existingApproval = await tx.pRApproval.findFirst({
      where: { prId, approverId: rejectedById },
    });
    if (existingApproval) {
      await tx.pRApproval.update({
        where: { id: existingApproval.id },
        data: {
          status: 'REJECTED_STATUS',
          comments: reason,
          actedAt: new Date(),
        },
      });
    }

    return tx.purchaseRequisition.update({
      where: { id: prId },
      data: {
        status: 'REJECTED_PR',
        rejectedAt: new Date(),
        rejectedById,
        rejectionReason: reason,
      },
      include: {
        items: true,
        requestedBy: { select: { id: true, firstName: true, lastName: true } },
        department: { select: { id: true, name: true, code: true } },
      },
    });
  });
}

export async function cancelPR(hospitalId: string, prId: string) {
  const pr = await prisma.purchaseRequisition.findFirst({
    where: { id: prId, hospitalId },
  });
  if (!pr) throw new NotFoundError('Purchase requisition not found');
  if (pr.status === 'CLOSED_PR' || pr.status === 'CANCELLED_PR') {
    throw new AppError('Cannot cancel a closed or already cancelled requisition', 400);
  }

  return prisma.purchaseRequisition.update({
    where: { id: prId },
    data: { status: 'CANCELLED_PR' },
  });
}

export async function getPendingApprovals(hospitalId: string, approverId: string) {
  // Get PRs pending this user's approval
  const approvals = await prisma.pRApproval.findMany({
    where: {
      approverId,
      status: 'PENDING_APPROVAL_STATUS',
      requisition: { hospitalId },
    },
    include: {
      requisition: {
        include: {
          requestedBy: { select: { id: true, firstName: true, lastName: true } },
          department: { select: { id: true, name: true, code: true } },
          _count: { select: { items: true } },
        },
      },
    },
    orderBy: { createdAt: 'asc' },
  });

  // Also get PRs in PENDING_APPROVAL or SUBMITTED status (for admins without explicit approval records)
  const pendingPRs = await prisma.purchaseRequisition.findMany({
    where: {
      hospitalId,
      status: { in: ['PENDING_APPROVAL', 'SUBMITTED'] },
    },
    include: {
      requestedBy: { select: { id: true, firstName: true, lastName: true } },
      department: { select: { id: true, name: true, code: true } },
      _count: { select: { items: true } },
    },
    orderBy: { createdAt: 'asc' },
  });

  return {
    myApprovals: approvals,
    allPending: pendingPRs,
  };
}
